<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		<style>
			* {
				padding: 0;
				margin: 0;
			}
			
			#main_container {
				width: 100vw;
				height: 90vh;
				background-color: #000;
				overflow-x: scroll;
				overflow-y: hidden;
				display: flex;
			}
			
			/* 1. Стилизация самого скроллбара */
			#main_container::-webkit-scrollbar {
				/* На мобильных устройствах с оверлейными скроллбарами 
				   эта высота может быть проигнорирована, но на десктопе сработает. */
				height: 5vh; 
			}

			/* 2. Стилизация дорожки (фона) */
			#main_container::-webkit-scrollbar-track {
				background: #222;
			}

			/* 3. Стилизация ползунка (движущейся части) */
			#main_container::-webkit-scrollbar-thumb {
				background: #aaa; 
			}

			/* 4. Изменение цвета ползунка при наведении */
			#main_container::-webkit-scrollbar-thumb:hover {
				background: #ccc; 
			}
			
			
			#map_container {
				width: 100vw;
				height: 85vh;
				background-color: blue;
				flex-shrink: 0;
				clip-path: view-box;
			}
			
			#map_image {
				background-color: red;
			}
			
			#table_container {
				min-width: 100vw;
				height: 85vh;
				background-color: green;
				flex-shrink: 0;
			}
			
			#menu_container {
				width: 100vw;
				height: 10vh;
				background-color: yellow;
				overflow: hidden;
				display: flex;
			}
			
			#menu_container .button {
				width: 8vh;
				height: 8vh;
				margin: 1vh;
				background-color: red;
			}
			
		</style>
	</head>
	<body>
		<div id="menu_container">
			<button class="button">
			</button>
		</div>
		<div id="main_container">
			<div id="map_container">
				<img id="map_image" src="https://www.bsmfuture.co.uk/assets/img/image15.jpg" />
			</div>
			<div id="table_container">
				<iframe style="width:100%; height: 100%;" src="https://www.bsmfuture.co.uk/assets/img/image15.jpg"></iframe>
			</div>
		</div>
		<script>
const element = document.getElementById('map_image');

// Состояние преобразования
let currentScale = 1;
let currentX = 0;
let currentY = 0;

// Состояния жеста
let initialPinchDistance = null;
let initialX = 0;
let initialY = 0; // Для панорамирования одним пальцем
let initialMidX = 0;
let initialMidY = 0; // Для коррекции зума

// Установим transform-origin в (0, 0) для упрощения расчётов
element.style.transformOrigin = '0 0';

element.addEventListener('touchstart', (e) => {
    e.preventDefault();

    if (e.touches.length === 1) {
        // Панорамирование: фиксируем начальную позицию касания относительно текущего смещения
        initialX = e.touches[0].clientX - currentX;
        initialY = e.touches[0].clientY - currentY;
        
    } else if (e.touches.length === 2) {
        
        // 1. Вычисляем начальное расстояние между пальцами
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDistance = Math.sqrt(dx * dx + dy * dy);

        // 2. Вычисляем начальный центр жеста (середина между пальцами)
        initialMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        initialMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    }
});

element.addEventListener('touchmove', (e) => {
    e.preventDefault();

    if (e.touches.length === 1) {
        // Логика панорамирования (1 палец):
        currentX = e.touches[0].clientX - initialX;
        currentY = e.touches[0].clientY - initialY;

        element.style.transform = `translate(${currentX}px, ${currentY}px) scale(${currentScale})`;

    } else if (e.touches.length === 2 && initialPinchDistance !== null) {
        
        // 1. Текущее расстояние и новый масштаб (newScale)
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx * dx + dy * dy);
        
        const scaleFactor = newDistance / initialPinchDistance;
        const newScale = scaleFactor * currentScale;

        // 2. Текущий центр жеста (Midpoint)
        const currentMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const currentMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

        // 3. Расчёт разницы в смещении
        // (Только эта часть решает проблему "прыжка"!)
        // Считаем, насколько сдвинулся центр жеста, и корректируем translate.
        const deltaX = currentMidX - initialMidX;
        const deltaY = currentMidY - initialMidY;

        // 4. Компенсация смещения
        // Мы используем разницу между старым и новым масштабом для коррекции
        const newOffsetX = currentX + deltaX - (initialMidX - currentX) * (scaleFactor - 1);
        const newOffsetY = currentY + deltaY - (initialMidY - currentY) * (scaleFactor - 1);

        element.style.transform = `translate(${newOffsetX}px, ${newOffsetY}px) scale(${newScale})`;
    }
});

element.addEventListener('touchend', (e) => {
    // 1. Если зум завершён, фиксируем новый масштаб и позицию.
    if (initialPinchDistance !== null) {
        const finalTransform = window.getComputedStyle(element).transform;
        const matrix = new DOMMatrix(finalTransform);
        
        currentScale = matrix.a; // Финальный масштаб
        currentX = matrix.e;     // Финальное смещение X
        currentY = matrix.f;     // Финальное смещение Y
        
        initialPinchDistance = null; // Сброс для следующего жеста
    }
    
    // Если панорамирование завершено, текущие X/Y уже зафиксированы
    // в touchmove, так что просто сбрасываем начальные точки.
    initialX = 0;
    initialY = 0;
});
		</script>
	</body>
</html>
