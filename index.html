<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		<style>
			* {
				padding: 0;
				margin: 0;
			}
			
			#main_container {
				width: 100vw;
				height: 90vh;
				background-color: #000;
				overflow-x: scroll;
				overflow-y: hidden;
				display: flex;
			}
			
			/* 1. Стилизация самого скроллбара */
			#main_container::-webkit-scrollbar {
				/* На мобильных устройствах с оверлейными скроллбарами 
				   эта высота может быть проигнорирована, но на десктопе сработает. */
				height: 5vh; 
			}

			/* 2. Стилизация дорожки (фона) */
			#main_container::-webkit-scrollbar-track {
				background: #222;
			}

			/* 3. Стилизация ползунка (движущейся части) */
			#main_container::-webkit-scrollbar-thumb {
				background: #aaa; 
			}

			/* 4. Изменение цвета ползунка при наведении */
			#main_container::-webkit-scrollbar-thumb:hover {
				background: #ccc; 
			}
			
			
			#map_container {
				width: 100vw;
				height: 85vh;
				background-color: blue;
				flex-shrink: 0;
			}
			
			#map_image {
				background-color: red;
			}
			
			#table_container {
				min-width: 100vw;
				height: 85vh;
				background-color: green;
				flex-shrink: 0;
			}
			
			#menu_container {
				width: 100vw;
				height: 10vh;
				background-color: yellow;
				overflow: hidden;
				display: flex;
			}
			
			#menu_container .button {
				width: 8vh;
				height: 8vh;
				margin: 1vh;
				background-color: red;
			}
			
		</style>
	</head>
	<body>
		<div id="menu_container">
			<button class="button">
			</button>
		</div>
		<div id="main_container">
			<div id="map_container">
				<img id="map_image" src="https://www.bsmfuture.co.uk/assets/img/image15.jpg" />
			</div>
			<div id="table_container">
				
			</div>
		</div>
		<script>
const element = document.getElementById('map_image');

// Состояния для зума
let initialPinchDistance = null;
let currentScale = 1;

// Состояния для панорамирования
let isDragging = false;
let startX = 0;
let startY = 0;
let offsetX = 0;
let offsetY = 0;

element.addEventListener('touchstart', (e) => {
    // Предотвращаем стандартное поведение браузера
    e.preventDefault();

    // Логика для ПАНОРАМИРОВАНИЯ (1 палец)
    if (e.touches.length === 1) {
        isDragging = true;
        startX = e.touches[0].clientX - offsetX;
        startY = e.touches[0].clientY - offsetY;
        
    // Логика для ЗУМА (2 пальца)
    } else if (e.touches.length === 2) {
        isDragging = false; // Отключаем панорамирование, если начался зум
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
    }
});

element.addEventListener('touchmove', (e) => {
    // Предотвращаем стандартное поведение браузера
    e.preventDefault();
    
    // Движение (ПАНОРАМИРОВАНИЕ)
    if (isDragging && e.touches.length === 1) {
        offsetX = e.touches[0].clientX - startX;
        offsetY = e.touches[0].clientY - startY;
        element.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${currentScale})`;
    } 
    
    // Зум (щипок)
    else if (e.touches.length === 2 && initialPinchDistance !== null) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx * dx + dy * dy);
        
        const scaleFactor = newDistance / initialPinchDistance;
        
        // Обновляем текущий масштаб
        const newScale = scaleFactor * currentScale;

        // Применяем зум и панорамирование вместе
        element.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${newScale})`;
    }
});

element.addEventListener('touchend', (e) => {
    isDragging = false;
    
    // Если жест "щипка" закончился
    if (initialPinchDistance !== null) {
        // Получаем финальное значение scale из CSS и обновляем currentScale
        const finalTransform = window.getComputedStyle(element).transform;
        const matrix = new DOMMatrix(finalTransform);
        currentScale = matrix.a; // "a" — это компонент scaleX в матрице преобразования
        
        initialPinchDistance = null; // Сбрасываем для следующего зума
    }
});
		</script>
	</body>
</html>
